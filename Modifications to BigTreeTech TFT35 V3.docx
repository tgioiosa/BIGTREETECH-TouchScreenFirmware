Modifications to BigTreeTech TFT35 V3.0 Source Code

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\Copy to SD Card root directory to update - Unified Menu Material theme\config.ini
  36,2: #//TG 11/1/20 changed from 5 to 6 for 250000 baud
  151,2: #//TG 11/1/20 changed this
  185,2: #//TG 11/1/20 changed BED was 150
  202,2: #//TG 11/1/20 changed these
  272,2: #//TG 11/1/20 modified these (6 maximum)
  313,3: ##//TG 11/1/20 enabled this
  318,2: #//TG 11/1/20 changed this was 0, SWX1 sensor is non-inverting
  323,2: #//TG increased due to false triggers (was 100)
  439,2: #//TG 11/1/20 enabled this
  444,2: #//TG 11/1/20 enabled this

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\menu.c
    5,1: //TG this code draws, handles, processes, and responds to menus

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\parseACK.c
 550,33: // Parse and store ABL type //TG Is this broken??

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\Settings.h
  30,40: #define ICON_FLASH_SIGN       20201031 //TG (YYYYMMDD) change if any icon(s) is added or removed

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\Menu\FeatureSettings.c
    4,1:  //TG Layout for the page
   55,1:  //TG here is where you would expand the list if needed, but also need to expand
  111,5:  //TG this list item has only a LABEL value, no ON/OFF TOGGLE (red dot)
 361,29:  #ifdef LED_COLOR_PIN  //TG only on the E3 version
 372,35:  #ifdef LCD_LED_PWM_CHANNEL  //TG LCD brightness control
 440,35:  void menuFeatureSettings(void)    //TG handles the Feature List Menu up,dn, and back buttons
 449,51:  key_num = menuKeyGetValue();                  //TG get a pressed key?
 452,51:  case KEY_ICON_5:                              //TG  up arrow, load prev list
 462,51:  case KEY_ICON_6:                              //TG  dn arrow, load next list
 472,51:  case KEY_ICON_7:                              //TG back arrow, load prev infoMenu

C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\Menu\SettingsMenu.c
 120,59:  {ICON_NULL,              LABEL_NULL},    //TG available button?
 121,59:  {ICON_NULL,              LABEL_NULL},    //TG available button?

Creating/Adding custom icon buttons to menus

To create a new icon for a button to be used in menus, first choose a name for the icon CUSTOM_1, then create a .bmp file for the button and name it CUSTOM_1.bmp

Now, to be able to use it in menus do the following:

First, we must add a few new keywords into these 4 files so the rest of the code knows about our new icon:

TFT\src\User\API\icon_list.inc				add   X_ICON (CUSTOM_1) this makes ICON_CUSTOM_1	
TFT\src\User\API\Language\Language.inc		add   X_WORD (CUSTOM_1) this makes LABEL_CUSTOM_1
TFT\src\User\API\Language\language_en.h		add   #define STRING_CUSTOM_1	  "TG Menu"
TFT\src\User\API\Language\language_keywords.h	add   #define LANG_KEY_CUSTOM_1	  "label_custom_1:"
Note: language_keywords.h is only needed if config file option is desired!

Any time a new keyword is added to the 4 files above, we have to change these signs in TFT\src\User\API\Settings.h:

#define LANGUAGE_FLASH_SIGN   20201107 //(YYYYMMDD) change if any keyword(s) in language pack is							 added or removed
#define ICON_FLASH_SIGN       20201107 //(YYYYMMDD) change if any icon(s) is added or removed

Now, to implement the new icon as a button in a menu, we find an empty slot in one of the existing menus and
modify the const MENUITEMS array for that parent menu. For example, we'll use the Settings Menu as the parent
menu for our new button because it has some empty positions in it (each menu page can have 7 buttons max).

So open the code file for the Settings Menu (TFT\src\User\Menu\SettingsMenu.c in this case).
We see there is a const MENUITEMS array named settingsItems and we also see this array has two unused
entries at indexes 5 and 6 (they're set to ICON_NULL,LABEL_NULL which means empty).
So we can add our new button in like so, replacing with our new values as shown below:
const MENUITEMS settingsItems = {
    // title
    LABEL_SETTINGS,
    // icon                     label
    {{ICON_SCREEN_SETTINGS,     LABEL_SCREEN_SETTINGS},
     {ICON_MACHINE_SETTINGS,    LABEL_MACHINE_SETTINGS},
     {ICON_FEATURE_SETTINGS,    LABEL_FEATURE_SETTINGS},
     {ICON_SCREEN_INFO,         LABEL_SCREEN_INFO},
     {ICON_CONNECTION_SETTINGS, LABEL_CONNECTION_SETTINGS},
     {ICON_CUSTOM_1,            LABEL_CUSTOM_1},     <-- we overwrite previous ICON_NULL, LABEL_NULL
     {ICON_NULL,          LABEL_NULL},	    with the icon name and text label of our custom icon
     {ICON_BACK,                LABEL_BACK},}
  };

Next, we need to add some code to handle what happens when our custom button is pressed. There's usually
a code block like the one shown shown below for the parent menu. It's usually found not too far after the
const MENUITEMS <parentmenu_name>  block we modified above. Put your handling code in this code block.

while(infoMenu.menu[infoMenu.cur] == menuSettings)
  {
    key_num = menuKeyGetValue();
    switch(key_num)
    {
      case KEY_ICON_0:
        OPEN_MENU(menuScreenSettings); //OPEN_MENU macro replaces infoMenu.menu[++infoMenu.cur] in newer versions
        break;

      case KEY_ICON_1:
        mustStoreCmd("M503 S0\n");
        infoMenu.menu[++infoMenu.cur] = menuMachineSettings;
        break;

      case KEY_ICON_2:
        infoMenu.menu[++infoMenu.cur] = menuFeatureSettings;
        break;

      case KEY_ICON_3:
        infoMenu.menu[++infoMenu.cur] = menuInfo;
        break;

      case KEY_ICON_4:
        infoMenu.menu[++infoMenu.cur] = menuConnectionSettings;
        break;

      case KEY_ICON_5:							<-- here we add the case for custom_1 button
        infoMenu.menu[++infoMenu.cur] = menuTGmenu;	    		    at position 5 in the menu. You can call
        break;								    another menu or handle some task here.
                             Also notice there is no KEY_ICON_6, 
      case KEY_ICON_7:							    since that menu position is blank.
        infoMenu.cur--;
        break;

      default:
        break;
    }
    loopProcess();
  }

Finally, we need to create a .c and .h module to perform some action (i.e. handle the menuTGmenu call above). Here is the C code file, TGmenu.c

#include "TGmenu.h"
#include "SendGcode.h"
#include "includes.h"
  
//extern char gcodeBuf[CMD_MAX_CHAR];
//char* gcodeBufPtr = &gcodeBuf[0];

void menuTGmenu(void)						<-- here is the new function to draw new menu
{
  //TG examples of variable usage
/*
static uint8_t ublSlot;
static bool ublIsSaving = true;
static bool ublSlotSaved = false;
*/

  

MENUITEMS TGmenuItems = {					<-- this is the new MENUITEMS structure
    // title
    LABEL_TGMENU,
    // icon                         label
    {{ICON_Z_0,                     LABEL_Z_0},
     {ICON_Z_300,                   LABEL_Z_300},
     {ICON_M503,                    LABEL_M503},
     {ICON_NULL,              LABEL_NULL},
     {ICON_NULL,              LABEL_NULL},
     {ICON_NULL,              LABEL_NULL},
     {ICON_NULL,              LABEL_NULL},
     {ICON_BACK,                    LABEL_BACK}}
  };

  KEY_VALUES key_num = KEY_IDLE;

The switch below is not used, just included to show how to modify an existing menu dynamically 
//TG this looks like an example of how to modify an existing menu on the fly based on
 //   information or other variables elsewhere in code
 /* switch (infoMachineSettings.leveling)
  {
    case BL_BBL:
      autoLevelingItems.title.index = LABEL_ABL_SETTINGS_BBL;
      break;

    case BL_UBL:
      autoLevelingItems.title.index = LABEL_ABL_SETTINGS_UBL;
      autoLevelingItems.items[1].icon = ICON_EEPROM_SAVE;
      autoLevelingItems.items[1].label.index = LABEL_SAVE;
      autoLevelingItems.items[2].icon = ICON_EEPROM_RESTORE;
      autoLevelingItems.items[2].label.index = LABEL_LOAD;
      break;

    default:
      break;
  }
*/


  menuDrawPage(&TGmenuItems);					<-- call to draw the menu

  while (infoMenu.menu[infoMenu.cur] == menuTGmenu)		<-- now wait in loop for an item to be pressed
  {
    key_num = menuKeyGetValue();				<-- find out what menu item was touched
    switch (key_num)						<-- do something for current touched menu item
    {
      case KEY_ICON_0:
        storeCmd("G1 Z0\n");
        break;

      case KEY_ICON_1:
        storeCmd("G1 Z300\n");
        break;

      case KEY_ICON_2:
      /*
      gcodeBuf[0]=(char)'M';
      gcodeBuf[1]=(char)'5';
      gcodeBuf[2]=(char)'0';
      gcodeBuf[3]=(char)'3';
      gcodeBuf[4]=(char)'/n';
      gcodeBuf[5]=0;
      storeCmd(gcodeBuf);
      */

        storeCmd("M503\n");
        //gcodeBuf[0] = 0;
        infoMenu.menu[++infoMenu.cur] = menuTerminal;
        break;

      case KEY_ICON_7:						<-- the "back" item sets current menu to previous
        infoMenu.cur--;
        break;

      default:
        break;
    }

    loopProcess();
  }
}
And here is the .h file, TGmenu.h

#ifndef _TGMENU_H_
#define _TGMENU_H_

   #ifdef __cplusplus
   extern "C" {
   #endif
   
   #include <stdbool.h>
   
   void menuTGmenu(void);
   
   #ifdef __cplusplus
   }
   #endif

#endif


We are done!


Creating a parameter available to set in the config.ini file

1. Define a keyword in TFT\src\User\API\config.inc 				example: X_CONFIG(BAUDRATE).
2. Put a #define in TFT\src\User\API\config.inc			#define CONFIG_BAUDRATE  "baudrate:"  (where "baudrate:" matches the way it appears in config.ini)
3. Then create a `string identifier' and value in TFT\src\User\config.ini, 	example:  baudrate:6 
4. Put a default #define in TFT\src\User\Configuration.h			example:  #define BAUDRATE 6	 
      (to define a default value if nothing is present in config.ini).
5. In file src\User\API\config.c must have a `case:' statement in function parseConfigKey() to process the keyword
       For example: case: C_INDEX_BAUDRATE, to set the value from the config.ini file.
6. In file TFT\src\User\API\Settings.h add the parameter to the SETTINGS struct for it to be available to the rest of the program and for EEPROM save/load.		
			
To have a parameter value changeable on the LCD Features page 		
	             
7. In file TFT\src\User\Menu\FeatureSettings.c         
  Add an "SKEY" keyword in the SKEY_LIST enum in file	example: SKEY_BAUDRATE		
 
8. In file TFT\src\User\API\Language\language_keywords.h  
  Add a `LANG_KEY' and text string to file			example: LANG_KEY_NEWNAME  "label_Baudrate:"
  				
9. In at least One TFT\src\User\API\Language\language.h file 
  Add a #define STRING_BAUDRATE			example: #define STRING_BAUDRATE  "Baudrate"		
10. In file TFT\src\User\API\Language\Language.inc
  Add an X_WORD (which becomes LABEL_name)    example: X_WORD (BAUDRATE) produces LABEL_BAUDRATE	
	              
11. In file TFT\src\User\Menu\FeatureSettings.c 
  Add a line item to LISTITEM settingPage[] in the order you want to see it, for example:
   {ICONCHAR_TOGGLE_ON,  LIST_TOGGLE,  LABEL_LASER_MODE,  LABEL_NULL} 		for an ON/OFF button	
        {ICONCHAR_BLANK,   LIST_CUSTOMVALUE,   LABEL_SPINDLE_ROTATION,    LABEL_CW} 		for a drop down list 
        (note: for a dropdown list you also need to define  a LABEL item array for possible list values) at top of FeatureSettings.c		
12. Add case: SKEY_BAUDRATE to functions updateFeatureSettings() and loadFeatureSettings() to handle loading and updating of the feature. 		

			
For an Icon only		
  1. create an X_ICON name in icon_list.inc		
  2. Add a LANG_KEY_name and string to language_keywords.h.  ex: LANG_KEY_ICONNAME  "Baudrate:"
  3. Add a #define STRING_NEWNAME to at least One language.h file  ex: #define STRING_BAUDRATE  "Baudrate " in language_en.h
  4. Add an X_WORD to Language.inc which will become LABEL_   ex: X_WORD (BAUDRATE) produces LABEL_BAUDRATE		
NOTE: After changing/adding/removing a keyword, change the CONFIG_FLASH_SIGN in Settings.h and PARA_SIGN in flashStore.c


Notes on Debugging the BTT TFT35 using PlatformIO and STLink probe

If you don't have a STLink probe, the STM32F4 discovery kit has a STLink V2 on-board and it can be configured to talk to the on-board STM32 chip or an External application board. To use the STM32F4 discovery kit as a pure STLink probe, remove the two jumpers which changes the board from Discovery to STLink mode. 



Next, connect  the external target board to connector  CN2 (pinout below).




Prepare the PlatformIO project for debugging

The source code project from BigTreeTech on GitHub is downloaded as a zip file. Once unzipped, opening the folder in PlatformIO should allow you to compile without errors. However, to use a debugger, several items need to be modified in the platformio.ini file (or through the platformio project GUI):

  # Add a custom board definition describing the board, mcu, flash, and RAM, etc.
  # Copy the custom board.json file to the buildroot\boards folder (and to whichever platform folder you want in %USER%\.platformio\platforms\CHOSEN PLATFORM\boards, so it will be available to any project)
  # Change platformio.ini settings so that a firmware.elf and firmware.bin are created
  # Setup PlatformIO debug options

Custom board creation

You can skip this step if the board you're debugging is already available in PlatformIO. This wasn't the case for the BTT35 and it's STM32F207VC chip, so one must be custom made.

You can start by finding an existing board that resembles your board and/or chip and use it as a base to modify.
There was an existing json file for the STM32F207VC in the buildroot\boards folder of the downloaded GitHub project, and an existing ST-Nucleo-F207ZG board with our chip in the PlatformIO boards database, so we'll use those as a base and make a few small changes.

One important note was to add the "product_line" token because a recent update to PlatformIO caused compile failures without it!

Here is the STM32F207VC.json board file and the changes (some from ST-Nucleo-F207ZG) needed in yellow:
{
  "build": {
    "core": "stm32",
    "cpu": "cortex-m3",
    "extra_flags": "-DSTM32F207xx",
    "f_cpu": "120000000L",
    "mcu": "stm32f207vct6",
    "product_line": "STM32F207xx",			<- needed to compile with latest PIO updates			 
    "variant": "stm32f2"
    "hwids": [						<- maybe not necessary but added to identify chip
      [
        "0x0411",
        "0x0002"
      ]
    ]			  
  },
  "connectivity": [
    "can",
    "ethernet"
  ],
  "debug": {
    "default_tools": [
      "stlink"						<- was cmsis-dap, needs to be stlink
    ],
    "jlink_device": "STM32F207VC",			<- make sure this is the right chip
    "onboard_tools": [
      "stlink"						<- was cmsis-dap, needs to be stlink
    ],
    "openocd_target": "stm32f2x",
    "svd_path": "STM32F20x.svd"
  },
  "frameworks": [
    "arduino",
    "cmsis",						<- extra supported framework choice added		
    "mbed",
    "stm32cube",					<- tried stm32cube, but had HAL errors on compile
    "libopencm3",					<- extra supported framework choice added
    "zephyr"						<- extra supported framework choice added			 
  ],
  "name": "BTT TFT35 V3",				<- give it a new appropriate name
  "upload": {
    "maximum_ram_size": 49152,			<- make sure flash and ram sizes are correct!
    "maximum_size": 262144,
    "protocol": "stlink",				<- was cmsis-dap, needs to be stlink
    "protocols": [
      "jlink",
      "stlink",
      "blackmagic",
      "mbed",
      "cmsis-dap",					<- extra supported protocol added
      "dfu"						<- extra supported protocol added
    ]
  },
  "url": "http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus/stm32f2-series/stm32f207/stm32f207vc.html",			<- updated to point to correct link for this chip
  "vendor": "ST"
}

The above file was renamed as btt_tft35_v3.json and saved to the project buildroot\boards folder and to %USER%\.platformio\platforms\ststm32\boards and ststm32@8.0.0\boards folders.


Making required changes to platform.ini for debugging

There are a lot of sections in this file, mostly concerned with all the optional environments for each of the BTT TFT variants. We can really simply this by removing all the un-needed targets, after all we only have the TFT35 V3.0 to work on so why not?

Hence we'll only look at the sections that need to be changed for stlink debugging to work.

The ini file begins with section [platformio], here is defined the source folder to be compiled, the path to the boards_dir, and the default_envs to be built. In our case, the only environment we want built is BIGTREE_TFT35_V3_0, although there can be multiples.

Next section is [common], use this to define keys and values that can be included into other sections by using the ${common.keyname} syntax to include them.

Next is a custom section named [stm32f2xx], it defines a default_src_filter key that includes the default_src_filter from the [common] section, and adds a few more filters particular to the STM32F2xx series chips. A build_flags key is defined that includes the build_flags from the [common] section and additionally defines "__STATIC_INLINE"  for the compiler as well as including some source/library files unique to the STM32F2xx series chips.

Finally we come to our defined environment section [env:BIGTREE_TFT35_V3_0]. The env: prefix denotes that this is an environment which can be chosen for the project. Here we define the platform, framework, and board that is pertinent to our system we want to debug. We also define the upload_protocol and debug_tool keys for our system. We define the src_filter and build_flag keys by expanding upon those in the [stm32f2xx] section. 
An extra_scripts key can also be put here or in the [common] section if needed. 
The debug_tool key is set here as stlink.


Note: The "as received from GitHub" platformio.ini file has an extra_scripts key in the [common] section or the [env:BIGTREE_TFT35_V3_0] section. One entry is pre:buildroot/scripts/custom_filename.py which renames the normal compiler output of firmware.bin to the form "HARDWARE"."SOFTWARE_VERSION", resulting in the file BIGTREE_TFT35_V3.0.26.x.bin.  Optionally another entry  key post:buildroot/scripts/short_out_filename.py is used to shorten the filename and get rid of the ".x".

Both of these entries need to be commented out so the standard compiler output will produce the files firmware.bin and firmware.elf (needed for the debugger) !


Now let's take a closer look at the platform.ini with all the changes for debugging:

[platformio]
src_dir = TFT
boards_dir=buildroot\boards		; use boards dir in project, comment out to use boards in core_dir
default_envs = BIGTREE_TFT35_V3_0	; our default build environment to use

[common]
; src_filter +/- determines what files to include when building
; use Hal/stm32f2_f4xx>, not Hal/stm32f10x, maybe better to move these to [stm32f10x], [stm32f2xx] sections
default_src_filter = +<src/*> -<src/Libraries> -<src/User/Hal/stm32f10x> +<src/User/Hal/stm32f2_f4xx>
build_flags = 
	-fmax-errors=5
	-g3				<- g3 for full debug symbols, g is normal release build
	-ggdb
	-Wno-missing-braces
	-DUSE_STDPERIPH_DRIVER=
	-ITFT/src/User/Fatfs		<-specifically tell compiler/linker to use these sources
	-ITFT/src/User/Hal
	-ITFT/src/User/Menu
	-ITFT/src/User/Variants
	-ITFT/src/User
	-ITFT/src/User/API
	-ITFT/src/User/API/UI
	-ITFT/src/User/API/Gcode
	-ITFT/src/User/API/Language
	-ITFT/src/User/API/Vfs
	-ITFT/src/User/Hal
	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Core/inc
	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Class/MSC/inc
	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Usr/inc
	-ITFT/src/User/Hal/STM32_USB_OTG_Driver/inc
	-DSOFTWARE_VERSION=26.x	<- used by custom_filename.py
	-DSOFTWARE_VERSION_SHORT=26   <- used by short_out_filename.py

extra_scripts = 
	pre:buildroot/scripts/custom_filename.py		<- these can stay here, but we will not use them in	
	post:buildroot/scripts/short_out_filename.py		<- our BIGTREE_TFT35_V3_0 environment, instead we
	post:buildroot/scripts/auto_gen_language_pack.py	<- will define our own 



[stm32f10x]		<- this is not used, maybe it can be deleted?
default_src_filter = ${common.default_src_filter} +<src/Libraries/cmsis/stm32f10x> +<src/Libraries/fwlib/stm32f10x> +<src/User/Hal/stm32f10x>
build_flags = 
	${common.build_flags}
	-D__STATIC_INLINE=
	-ITFT/src/Libraries/cmsis/Core-CM3
	-ITFT/src/Libraries/cmsis/stm32f10x
	-ITFT/src/Libraries/fwlib/stm32f10x
	-ITFT/src/Libraries/fwlib/stm32f10x/inc
	-ITFT/src/User/Hal/stm32f10x

[stm32f2xx]		<- we want this one
; don't use cmsis/stm32f2xx, but use fwlib/stm32fxx and use HAL from project
default_src_filter = ${common.default_src_filter} -<src/Libraries/cmsis/stm32f2xx> +<src/Libraries/fwlib/stm32f2xx> +<src/User/Hal/stm32f2_f4xx>
build_flags = 
	${common.build_flags}
	-D__STATIC_INLINE=
	-ITFT/src/Libraries/cmsis/Core-CM3		<-specifically tell compiler/linker to use these sources
	-ITFT/src/Libraries/cmsis/stm32f2xx
	-ITFT/src/Libraries/fwlib/stm32f2xx
	-ITFT/src/Libraries/fwlib/stm32f2xx/inc
	-ITFT/src/User/Hal/stm32f2_f4xx


[env:BIGTREE_TFT35_V3_0]				<- our desired environment section
build_type = debug
debug_build_flags = -O1  - ggdb3  - g3
debug_tool = stlink		; use stlink for debugging
debug_load_mode = modified				; upload to target only when firmware is modified
debug_load_cmds = 
  set remotetimeout 120					; set target response timeout to 2 minutes
  show remotetimeout					; display value to make sure it set
platform = ststm32@11.0.0	; specifically use version 11.0.0
framework = cmsis
board = btt_tft35_v3		; custom board in buildroot\boards
;upload_protocol = stlink				; stlink not supported by cmsis-dap, so we have to use stlink here
upload_protocol = custom	<- define a custom protocol cause the built-in upload writes flash at 0x08000000
upload_command =  $PROJECT_PACKAGES_DIR\tool-stm32duino\texane-stlink\st-flash write $SOURCE 0x8008000

; don't include Startup folder from project, it conflicts with same files in core_dir
src_filter = ${stm32f2xx.default_src_filter} -<src/Libraries/Startup/stm32f2xx>
extra_scripts = 
	;pre:buildroot/scripts/custom_filename.py   ;comment out to keep output as firmware.bin and firmware.elf
	buildroot/scripts/stm32f2xx_0x8000_iap.py
	;post:buildroot/scripts/bin2elf.py		<- I'm testing this to copy named.bin to named.elf instead
build_flags = 
	${stm32f2xx.build_flags}
	-DSTM32F2XX=
	-DHSE_VALUE=8000000ul
   -DVECT_TAB_FLASH=0x08008000	<- for some reason this is ignored so we have a custom upload protocol texane-stlink with base set to 0x08008000
	-DRAM_SIZE=48					; Available RAM size in kbytes
	-DHARDWARE="BIGTREE_TFT35_V3.0"		<- used by custom_filename.py		
	-DHARDWARE_SHORT="B35V30"			<- used by custom_filename.py		   
	-DTFT35_V3_0=
extra_scripts = 
   pre:buildroot/scripts/custom_filename.py		; changes filenames to BIGTREE_TFT35_V3.0.26.x
	buildroot/scripts/stm32f2xx_0x8000_iap.py		; linker script
	post:buildroot/scripts/bin2elf.py			; names the elf file for debugger
   ;post:buildroot/scripts/auto_gen_language_pack.py	;optional  -  rebuilds language.ini
   
We also need to make sure we have all the extra_scripts present in buildroot\scripts folder, so put a copy of our custom made script file bin2elf.py there. This script copies an ELF file to the output directory for debugging build with a unique filename other than firmware.bin.


Setup PlatformIO debug options

At this point you should be able to click the debug icon in PlatformIO on the left side and the debug panel will open. At the top there may be a pulldown menu with some options (see below)




We are almost ready to Click a debug option and Run! 
 
You must click the one that does not skip the Pre Debug step if you haven't built the project, or you may get a task error.
After doing this once you should be able to run either option.

You can also run by clicking the PIO bug icon to bring up project tasks. Then select a task and under the advanced tab you can do a number of things like test, check, Pre-Debug, Build, Upload, etc.

If you get errors, you may have to check launch.json to get things fixed. 



Appendix A: Here is the bin2elf.py script

Import("env")					<- gives access to the PIO environment variables
import shutil					<- shell utilities for the copyfile command
def bin2elf(source, target, env):			<- defines a function call for the code below
    print("copying firmware to ELF...")
    firmware_name = env['PROGNAME']		<- gets the HARDWARE.VER  name i.e. BIGTREE_TFT35_V3.0.26.x
    firmware_path = env.subst('$BUILD_DIR') + "/"  <- gets the path to the build output i.e.  pio\build\env_name    #print(firmware_name)    #print(firmware_path)
    shutil.copyfile(firmware_path + firmware_name, firmware_path + firmware_name + ".elf")  <- copy to an .elf extension
    print("elf file created.")
    #env.Replace($PROGNAME="firmware_%s" % "elf" )
env.AddPostAction("buildprog", bin2elf)		<- adds this function to the environment's PostAction list
						    to execute a script AFTER the compile/link completes.
						    It has to be done this way. Simply adding the script.py
						    to the extra_scripts= keyword post: prefix (post:script.py)
                   does run it at the end of compiler/linker, it will run before



Additions/Changes for AVR128DB28 Triac Controller version	7/22  -  10/22

The following M codes were added as new commands to Marlin and the TFT35
M codes for data exchange between Marlin and TFT35 screen over UART,  direction is from the TFT point of view

Mcode   	Function            	TFT SEND to Marlin        	 	Marlin RETURN to TFT       	*If CMD issued from REMOTE USB host
-------  	--------------    	 --------------------------------------------- 	------------------------   	-------------------------------------------------
M7900    AVRBlockInfo(-PID)   use M7900 F....                    		M7900 R           		*will echo to REMOTE SERIAL
M7979    PID flag          	 use M7979 Sx                       		M7900 (blockinfo) 		*also echoes to REMOTE SERIAL
M7980    RESET AVR flag          use M7980                          		none              		*will reset the AVR, echo ok only
M7981    PID Kp,Ki,Kd      	 use M7981 Px Ix Dx                 		M7981 R           		*also echoes to REMOTE SERIAL
M7982    AVR Display Page      use M7982 Px                       		M7900 (blockinfo) 		*will change page, echo ok only
M7983    AVR PID speed           use M7983 Sx (0, 1, 2)            		M7900 (blockinfo) 		*will change preset, echo ok only
M7984    AVR PID Reload         use M7984 Sx (1=current 2=default) 	M7900 (blockinfo) 		*will reload, echo ok only
M7985    Vacuum Enable          happens via M42 P122               	see M42()         		*no response (must use M42 cmd)
M7986    Stock Top Z-axis         from printing M7986 Rx             	M7986 Tx Zx       		*instructs Marlin to:
                                                                                  						 R=Get Stock_Top from current Z and subtract
                                                                                  						 probe plate thickess(value after R)
                                                                                  						 S=Get Stock_Top from print gcode (val after S)
                                                                                  						 (already corrected for probe thickness)
                                                                                  						*Results echoed only to the TFT SERIAL_PORT!
Added G code(s)
G39	Returns the active WCS workspace from Marlin
G39 T	Returns a table of all Workspaces (G53  -  G62) from Marlin

The currently active workspace is also sent with the Temperature Auto Report at the end of the string as follows:
The string contains Bed Temp Act/Set, Spindle Speed Act/Set, and active WCS (ignore the @:0 B@:0)
Example:  B:25.00 /0.00 S0:0.00 /0.00 @:0 B@:0 WCS: -1

A new menu for AVRTriac has been added to manage settings for PID speed control, resetting the AVR Control board, and changing the page displayed on the four line LCD on the AVR control board.
The menu allows selecting from four PID presets, slow, normal, fast, and custom. You can only make parameter changes with the custom preset (the others can be changed in the firmware only). Any changes made will result in a prompt asking you if the changes should be save to the AVR EEPROM as the new default settings. These include PID ON/OFF state, Displayed Page, Selected PID preset, and/or any Custom PID parameter changes while in Custom preset. If you select OK, the new settings are stored and become the default at start up. If you select Cancel, no changes are saved when you exit back out of the AVRTriac Menu, and the default is restored and will be shown on re-entry to the AVRTriac Menu.

(If there is a problem with I2C comm when making changes or saving them, a popup message will prompt you to Reset the AVR control to try to recover).

A new feature setting was added called "Should M0 Pause". When this is turned off, incoming M0 Stops won't show an additional "pause" popup. This reduces the screen clutter by having one less prompt to answer.

The arrangement of the Z-Axis homing and probing has been changed in Marlin Configuration. The Z endstop sensor is moved to the ZMAX connector on the SGEN board. The Z_HOME_DIR is changed from -1 to 1 so that the tool travels upwards to find home position. This position is Z_MAX_POS. Physically, this is 65mm up from the spoilboard, but logically it represents Home (ZERO).
Then the Z_MIN_POS limit is -65mm to the spoilboard as the tool travels negative during a print. There is no ZMIN endstop, so we rely on software endstops to stop there. Then the configuration becomes:
 
#define Z_MIN_POS -65 	//TG 9/30/2022 min travel of MPCNC (w/15.7mm tool length) just hits spoilboard (if Z Homing down use 0, Z Homing up use -65)
#define X_MAX_POS X_BED_SIZE
#define Y_MAX_POS Y_BED_SIZE
#define Z_MAX_POS 0	  //TG 9/30/2022 max travel of MPCNC before rising past lower bearings (if Z Homing down use 65, Z Homing up use 0)

For probing stock, the probe is connected to the ZMIN connector on the SGEN board and the probe will move from Home(ZERO) down toward the workpiece. When the probe makes contact we get the Z-position of the stock top.
G1 Z0 or G28 Z cannot be used for probing, since they go upward in travel. We have to use G38.x to probe to target. By giving
G38.3 Z-65 we send the probe down towards -65mm (our spoilboard surface, or Z = physical zero). When the probe triggers we capture the Z position as the top of the work surface.
Once we have that number, we can use G54 to move to another WCS workspace in Marlin, followed by G92 Z0 will set the current Z position (our work surface top) as the new ZERO for all further operations and run the job.

NOTE: During the job in WCS 0 (G54), if there is a need to switch tools and re-probe the work surface top, we must first switch back to native workspace WCS -1 (G53) and repeat the above for the new work surface position. The nc post processor will handle all of this automatically and will return the system to native workspace WCS -1 (G53) at the end of the job. Be sure to use the latest post processor in Fusion 360 which is TG MPCNC_V3_3.cps.

NOTE: If the job is aborted at any point, the TFT35 will handle stopping the spindle, lifting the tool, return to X0 Y0 Z0, and return  the system to native workspace WCS -1 (G53).

Additions/Changes for VFD Controller version	12/22  -  12/26

The following M codes were added as new commands to Marlin and the TFT35
M codes for data exchange between Marlin and TFT35 screen over UART,  direction is from the TFT point of view

Mcode   	Function            	TFT SEND to Marlin        	 	Marlin RETURN to TFT       	*If CMD issued from REMOTE USB host
-------  	--------------    	 --------------------------------------------- 	------------------------   	-------------------------------------------------
M7987    VFD Status   	 none  -  Marlin sends every 2 secs           M7987  OF,SF,OC,....DP           	*will echo to REMOTE SERIAL
M7988    VFD S/W Ver..          	 use M7988  R                       		M7988  SW,CP,BR,FT	*also echoes to REMOTE SERIAL
M7989    VFDpresent flag         use M7980  R                        		M7989  VFD              	*will reset the AVR, echo ok only

Also, modules vfd.c and vfd.h were added to support vfd functions.
#ifdef USING_VFD_CONTROLLER was added in areas to only include vfd code if USING_VFD_CONTROLLER is defined.
#ifdef USING_AVR_TRIAC_CONTROLLER was added in areas to only include AVRTriac code if USING_AVR_TRIAC_CONTROLLER is defined.
These macros are used in SettingsMenu.c to select the correct Icon for KEY_ICON_5 on the settings screen.
The following new function was added to GUI.c to provide drawing pseudo-LED widgets
//TG 12/23/22 draw a single radio button of color with text, specify text pos as RIGHT or BOTTOM
void RADIO_Create_Single(uint16_t sx, uint16_t sy, uint16_t color, char *text, uint16_t txtdir)  
And lastly, a new icon was created for VFD Control.    
